<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GRE背单词之战</title>
    <url>/20220121/GRE%E8%83%8C%E5%8D%95%E8%AF%8D%E4%B9%8B%E6%88%98/</url>
    <content><![CDATA[<p>记录一下背单词的经历</p>
<img src="https://download.yumie.xyz/img/image-20220121113113601.png" alt="image-20220121113113601" style="zoom:25%;" />

<span id="more"></span>

<p>最开始用的是墨墨背单词，断断续续用了半年，发现效率太低了，半年才背了三百多个单词</p>
<p>这个寒假，看了孟一博的GRE填空课，才知道我的背单词方法错了。</p>
<p>单词应该是泛泛地背，网课老师给的计划是一天200个，尽力去背，能背多少背多少，7天背完核心词1500，然后反过头来继续背。刷个三四遍就差不多了。</p>
<p>我也在网上找到别人的背单词经验，说的很有道理：</p>
<blockquote>
<p>先大概记住单词的意思，然后边做题边背。在做题是遇到可以巩固记忆，也更好记住这个单词的最合适语境和含义</p>
</blockquote>
<p>下面分享一下我最开始刷单词的时候的方法：</p>
<p>使用词书：<img src="https://download.yumie.xyz/img/image-20220121114727380.png" alt="image-20220121114727380"></p>
<img src="https://download.yumie.xyz/img/image-20220121114815083.png" alt="image-20220121114815083" style="zoom: 25%;" />

<p>①  每天规定200个，10个一组</p>
<p>②  配合anki，背完一组就把他录入anki中，让anki算法帮我安排复习</p>
<p>③  全部过完一遍之后，复习anki + 单词表。 交叉记忆记得更牢。</p>
<p>④   做题巩固</p>
<h4 id="1月21号记录："><a href="#1月21号记录：" class="headerlink" title="1月21号记录："></a>1月21号记录：</h4><p>先复习之前背过的50个单词</p>
<img src="https://download.yumie.xyz/img/image-20220121115013335.png" alt="image-20220121115013335" style="zoom: 33%;" />]]></content>
      <tags>
        <tag>英语</tag>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题汇总</title>
    <url>/20220120/Next%E4%B8%BB%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>Github Pages + Hexo + Next主题</p>
<p>配置心得</p>
<img src="https://download.yumie.xyz/img/image-20220120222925508.png" alt="image-20220120222925508" style="zoom: 50%;" />

<span id="more"></span>

<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul>
<li>常见命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span>      <span class="comment"># 新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment"># 新建页面</span></span><br><span class="line">hexo generate            <span class="comment"># 生成静态页面至public目录</span></span><br><span class="line">hexo server              <span class="comment"># 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy              <span class="comment"># 部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>                <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version             <span class="comment"># 查看Hexo的版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缩写命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<ul>
<li>组合命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s -g   <span class="comment"># 生成并本地预览</span></span><br><span class="line">hexo d -g   <span class="comment"># 生成并上传</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写文章</li>
</ul>
<p>我们可以在 hexo 根目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分隔符</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="GitHub-Pages-绑定域名"><a href="#GitHub-Pages-绑定域名" class="headerlink" title="GitHub Pages 绑定域名"></a>GitHub Pages 绑定域名</h1><h2 id="解析DNS"><a href="#解析DNS" class="headerlink" title="解析DNS"></a>解析DNS</h2><p>我采用的是腾讯云下面的poddns</p>
<p><img src="https://download.yumie.xyz/img/image-20220120153537822.png" alt="image-20220120153537822"></p>
<p>配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下 4 个 IP 地址中的至少一个。</p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153</li>
</ul>
<p>上述设置的解释：</p>
<ul>
<li>设置 A 记录的意思是，当我输入 <code>yumie.xyz</code> 这个域名的时候，访问的是 <code>185.199.108.153</code> 这个地址；</li>
<li>设置 CNAME 的意思是，当我访问 <code>agecspnt.github.io</code> 这个地址的时候，会跳转到 <code>yumie.xyz</code>，之后的过程就和 A 记录相同了，即访问 <code>185.199.108.153</code>。</li>
</ul>
<h2 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h2><p>在 Hexo 本地目录中的 source 文件夹里，添加一个命名为 CNAME 的无后缀文件，文件中的填写你的域名。</p>
<p>如果你想让地址栏的域名显示 www 前缀就输入 <code>www.xxxxx.com</code>，否则输入 <code>xxxxx.com</code> 即可。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">www.yumie.xyz</span><br></pre></td></tr></table></figure>

<h2 id="Github-Pages-对自定义域上-Https"><a href="#Github-Pages-对自定义域上-Https" class="headerlink" title="Github Pages 对自定义域上 Https"></a>Github Pages 对自定义域上 Https</h2><p>然后我们在 Github Pages 项目中 Settings 选项卡 Github Pages 选项：在 Custom domain 添加你的自定义域名。</p>
<p>刷新页面 如果能勾选 Enforce HTTPS 即完成。</p>
<p>建议一定要弄个ssl证书来开启HTTPS，要不然之后还会出现图片加载不出来的问题</p>
<p><img src="https://download.yumie.xyz/img/image-20220120154000312.png" alt="image-20220120154000312"></p>
<h1 id="配置-CDN-进行加速"><a href="#配置-CDN-进行加速" class="headerlink" title="配置 CDN 进行加速"></a>配置 CDN 进行加速</h1><p>由于 Github Pages 的服务并不是那么稳定，近期出现多次不能正常部署或访问 Pages 的问题，所以我现在采用了<strong>博客部署在 GitHub Pages 上并且配置 CDN 进行加速</strong>的方法。</p>
<p>国内的 CDN 服务提供商有不少，但是基本都需要备案，因此我用了 Cloudflare 这个国外的 CDN 服务提供商。</p>
<p>配置 CDN 的过程见：</p>
<ul>
<li><a href="https://tding.top/archives/12c6c559.html">Hexo 配置 Cloudflare 免费 CDN</a></li>
</ul>
<h1 id="Hexo-主题NexT"><a href="#Hexo-主题NexT" class="headerlink" title="Hexo 主题NexT"></a>Hexo 主题NexT</h1><p>Hexo 有很多简洁美观的主题，大家可以去 <a href="https://hexo.io/themes/">Hexo-Themes</a> 去选择自己喜欢的主题。</p>
<p>我只用过next这一款主题，下面是我美化过程的一个记录。</p>
<h2 id="根目录结构"><a href="#根目录结构" class="headerlink" title="根目录结构"></a>根目录结构</h2><p><img src="https://download.yumie.xyz/img/image-20220120154451699.png" alt="image-20220120154451699"></p>
<p>这是Hexo的根目录，下面解析一下每个目录是干啥用的：</p>
<ul>
<li>点开头的文件夹：直接无视，这是一些IDE、git配置文件，不用管</li>
<li>node_modules:  Node.js的包存放的地方，一般不用看</li>
<li>public: 用过hexo g命令后生成静态文件的地方</li>
<li>scaffolds：模板文件夹，生成新page或者post时的模板存放目录</li>
<li>source：可以理解为源代码，文章一般都在这里面写</li>
<li>themes：各种主题的配置文件</li>
<li>_config开头的文件：都是主题配置文件，其中__config.yml是全局配置文件</li>
</ul>
<h2 id="themes目录结构"><a href="#themes目录结构" class="headerlink" title="themes目录结构"></a>themes目录结构</h2><p><img src="https://download.yumie.xyz/img/image-20220120155250890.png" alt="image-20220120155250890"></p>
<p>在这个文件夹里你可以看到你已经安装的主题</p>
<p>拿next来举例</p>
<ul>
<li>docs: 一些主题的说明文档</li>
<li>languages：各种语言的配置文件</li>
<li>layout：布局文件，需要经常调整</li>
<li>script：JavaScript文件，一般不用动</li>
<li>source：用来修改样式，经常需要改动</li>
</ul>
<h1 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h1><p>图片放到github page上加载很慢，所以我使用七牛云来储存图片</p>
<p>还有一个优点：本地编辑markdown文件也会方便很多！</p>
<p>使用PicGo，在typora里面配置好</p>
<p><img src="https://download.yumie.xyz/img/image-20220120155800342.png" alt="image-20220120155800342"></p>
<p>七牛云的注册教程自行百度</p>
<p>注意七牛云的域名，域名的HTTPS问题</p>
<h1 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h1><h2 id="大陆特色问题"><a href="#大陆特色问题" class="headerlink" title="大陆特色问题"></a>大陆特色问题</h2><h3 id="npm装包总是装不上？"><a href="#npm装包总是装不上？" class="headerlink" title="npm装包总是装不上？"></a>npm装包总是装不上？</h3><p>安装cnpm，就可以用国内源安装了</p>
<h3 id="git上传总是失败？？"><a href="#git上传总是失败？？" class="headerlink" title="git上传总是失败？？"></a>git上传总是失败？？</h3><p>第一句在git bash cd到博客根目录运行，可以解决10043问题</p>
<p>后两句可以解决open ssl failed之类的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h1 id="NexT主题配置细节"><a href="#NexT主题配置细节" class="headerlink" title="NexT主题配置细节"></a>NexT主题配置细节</h1><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><h3 id="设置-hexo-的-next-主题"><a href="#设置-hexo-的-next-主题" class="headerlink" title="设置 hexo 的 next 主题"></a>设置 hexo 的 next 主题</h3><p>我们在站点的配置文件<code>_config.yml</code> 中找到 theme 后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next  # 配置成刚下载的next主题</span><br></pre></td></tr></table></figure>

<h3 id="配置-hexo-网站相关信息"><a href="#配置-hexo-网站相关信息" class="headerlink" title="配置 hexo 网站相关信息"></a>配置 hexo 网站相关信息</h3><p>我们在站点的配置文件<code>_config.yml</code> 中，修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:          # 网站标题</span><br><span class="line">subtitle:       # 网站副标题</span><br><span class="line">description:    # 描述，介绍网站的</span><br><span class="line">keywords:       # 网站的关键字</span><br><span class="line">author:         # 博主姓名</span><br><span class="line">language: zh-CN # 语言：zh-CN 是简体中文</span><br><span class="line">timezone: UTC   # 时区</span><br></pre></td></tr></table></figure>

<p>注意：博客框架默认的语言是英文，我们需要到 <code>/themes/next/languages</code> 目录下，查看当前 NexT 版本简体中文对照文件的名称是 <code>zh-Hans</code> 还是 <code>zh-CN</code>。这里是 <code>zh-CN</code>。</p>
<h3 id="配置-hexo-中的-about、tag、links菜单"><a href="#配置-hexo-中的-about、tag、links菜单" class="headerlink" title="配置 hexo 中的 about、tag、links菜单"></a>配置 hexo 中的 about、tag、links菜单</h3><p>默认的主题配置文件<code>_config.yml</code> 中，菜单只开启了首页和归档，我们根据需要，可以添加 about、tag、categories、sitemap 等菜单，所以把它们也取消注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 菜单设置为 菜单名: /菜单目录 || 菜单图标名字</span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  sitemap: /sitemap.xml || sitemap</span><br><span class="line">  commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true   # 显示图标</span><br><span class="line">  badges: true  # 显示统计信息</span><br></pre></td></tr></table></figure>

<p>注：hexo 所有图标均来自 fontawesome，其中 <code>||</code> 后面是你想要设置的图标的名字。</p>
<h3 id="手动生成-hexo-菜单对应文件"><a href="#手动生成-hexo-菜单对应文件" class="headerlink" title="手动生成 hexo 菜单对应文件"></a>手动生成 hexo 菜单对应文件</h3><p>新菜单开启后是没有对应文件的，所以要手动生成 about、tags、categories、404 页面。</p>
<h4 id="新建-about-页面"><a href="#新建-about-页面" class="headerlink" title="新建 about 页面"></a>新建 about 页面</h4><p><code>about</code> 页面一般用来介绍站点信息和博主信息。</p>
<p>我们可以在博客根目录下输入以下命令新建页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>然后你会发现多了一个 <code>hexo/source/about</code> 文件夹，里面有一个 <code>index.md</code> 文件，你可以根据自己的需要在这个 Markdown 文件中写一些内容（同文章一样，用 Markdown 语法）。</p>
<h4 id="新建一个-tags-页面"><a href="#新建一个-tags-页面" class="headerlink" title="新建一个 tags 页面"></a>新建一个 tags 页面</h4><p>同样的，我们可以新建 <code>tags</code> 页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在 <code>tags</code> 页面文件 <code>hexo/source/tags/index.md</code> 的头部修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-06-29 11:35:42   # 时间随意</span><br><span class="line">type: &quot;tags&quot;                # 类型一定要为tags</span><br><span class="line">comments: false             # 提示这个页面不需要加载评论</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="新建一个-categories-页面"><a href="#新建一个-categories-页面" class="headerlink" title="新建一个 categories 页面"></a>新建一个 categories 页面</h4><p>同样的，我们可以新建 <code>categories</code> 页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 <code>categories</code> 页面文件 <code>hexo/source/categories/index.md</code> 的头部修改为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-10-15 00:03:57</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h4 id="新建一个-404-页面"><a href="#新建一个-404-页面" class="headerlink" title="新建一个 404 页面"></a>新建一个 404 页面</h4><p>这里我们将 404 替换成腾讯的公益页面。</p>
<p>首先我们在 <code>hexo/source</code> 目录下创建自己的 <code>404.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;返回&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Hexo 博客的基本内容是一些 Markdown 文件，放在 <code>source/_post</code> 文件夹下，每个文件对应一篇文章。除此之外，放在 source 文件夹下的所有开头不是下划线的文件，在 <code>hexo generate</code> 的时候，都会被拷贝到 public 文件夹下。但是，<strong>Hexo 默认会渲染所有的 HTML 和 Markdown 文件</strong>。</p>
</blockquote>
<p>因此我们可以简单地在文件开头加上 <code>layout: false</code> 一行来避免渲染：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">+layout: false</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;head&gt;</span></span><br><span class="line"><span class="code">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="code">        &lt;title&gt;404&lt;/title&gt;</span></span><br><span class="line"><span class="code">    &lt;/head&gt;</span></span><br><span class="line"><span class="code">    &lt;body&gt;</span></span><br><span class="line"><span class="code">        &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;返回&quot;&gt;&lt;/script&gt; </span></span><br><span class="line"><span class="code">    &lt;/body&gt;</span></span><br><span class="line"><span class="code">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就完成了 404 页面的创建。</p>
<p>注意：本地测试不出来，发布出来就可以了。</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="配置-hexo-中-next-主题样式选择"><a href="#配置-hexo-中-next-主题样式选择" class="headerlink" title="配置 hexo 中 next 主题样式选择"></a>配置 hexo 中 next 主题样式选择</h3><p>NexT 一共提供了 4 种首页样式，按照自己喜好选择一个，选择一个其他主题样式后其他的主题前一定要加上注释<code>#</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="头像信息设置"><a href="#头像信息设置" class="headerlink" title="头像信息设置"></a>头像信息设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: /images/avatar.jpg  # 设置头像资源的位置</span><br><span class="line">  rounded: true            # 开启圆形头像</span><br><span class="line">  opacity: 1               # 不透明的比例：0就是完全透明</span><br><span class="line">  rotated: false           # 不开启旋转</span><br></pre></td></tr></table></figure>

<h3 id="社交信息和友链配置"><a href="#社交信息和友链配置" class="headerlink" title="社交信息和友链配置"></a>社交信息和友链配置</h3><p>这里和菜单设置格式一样，<code>社交名字: 社交url || 社交图标</code>，图标信息来自 <a href="https://fontawesome.com/v4.7.0/icons">fontawesome</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social: </span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  Google: https://plus.google.com/yourname || google</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true      # 显示社交图标</span><br><span class="line">  icons_only: false # 只显示图标，不显示文字</span><br></pre></td></tr></table></figure>

<h3 id="更改动画和动画速度"><a href="#更改动画和动画速度" class="headerlink" title="更改动画和动画速度"></a>更改动画和动画速度</h3><p>更改动画比较简单，在主题配置文件里找到motion即可更改，下面是我的方案</p>
<p><img src="https://download.yumie.xyz/img/image-20220120161604662.png" alt="image-20220120161604662"></p>
<p>这里面的效果都可以在<a href="https://theme-next.js.org/animate/%E7%BD%91%E7%AB%99%E4%B8%AD%E9%A2%84%E8%A7%88">https://theme-next.js.org/animate/网站中预览</a></p>
<p>动画速度我查了好久才知道在哪改：</p>
<p>在motion.js (我一直以为它叫animate.js…)</p>
<p><img src="https://download.yumie.xyz/img/image-20220120161905826.png" alt="image-20220120161905826"></p>
<p>在这里面搜索duration，即可定位：</p>
<p><img src="https://download.yumie.xyz/img/image-20220120162022892.png" alt="image-20220120162022892"></p>
<p>我习惯改的快一点，要不然网站会感觉卡卡的</p>
]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Python快速排序</title>
    <url>/20220120/Python%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>刷题记录</p>
<img src="https://download.yumie.xyz/img/image-20220120222234381.png" alt="image-20220120222234381" style="zoom:25%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120214249620.png" alt="image-20220120214249620"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">nums, i, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= j:  <span class="comment"># 如果数组长度为0或1，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 仅表示终止函数，相当于return None</span></span><br><span class="line">    low, high = i, j</span><br><span class="line">    pivot = nums[(i + j) // <span class="number">2</span>]  <span class="comment"># 地板除</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        <span class="keyword">while</span> low &lt;= high <span class="keyword">and</span> nums[low] &lt; pivot:  <span class="comment"># 找到一个小于pivot的数</span></span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high <span class="keyword">and</span> nums[high] &gt; pivot:  <span class="comment"># 找到一个大于pivot的数</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> low &lt;= high:</span><br><span class="line">            nums[low], nums[high] = nums[high], nums[low]  <span class="comment"># 交换这两个前面找到的数，交换过后，也不要忘了low和high的值要改变</span></span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">    quicksort(nums, i, high)</span><br><span class="line">    quicksort(nums, low, j)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    array = [<span class="built_in">int</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    quicksort(array, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>成功AC</p>
<p><img src="https://download.yumie.xyz/img/image-20220120214327522.png" alt="image-20220120214327522"></p>
<p>写了这道题才知道，之前数据结构课上学的快速排序我记错了（考试当然也写错了）。</p>
<p>它是每一轮左右两边要各找到一个数再进行交换，而不是一边找到就交换。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm(含专业版)安装教程</title>
    <url>/20220119/PyCharm(%E5%90%AB%E4%B8%93%E4%B8%9A%E7%89%88)%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>介绍PyCharm的安装方法–小白也能轻松学会！</p>
<img src="https://download.yumie.xyz/img/image-20220120222839647.png" alt="image-20220120222839647" style="zoom: 25%;" />

<span id="more"></span>

<h2 id="社区版和专业版的区别"><a href="#社区版和专业版的区别" class="headerlink" title="社区版和专业版的区别"></a>社区版和专业版的区别</h2><h3 id="功能上的区别："><a href="#功能上的区别：" class="headerlink" title="功能上的区别："></a>功能上的区别：</h3><p>PyCharm 专业版是功能最丰富的，与社区版相比，PyCharm 专业版增加了 Web 开发、Python Web 框架、Python 分析器、远程开发、支持数据库与 SQL 等更多高级功能。</p>
<p>PyCharm 的社区版中没有 Web 开发、Python We 框架、Python 分析器、远程开发、支持数据库与 SQL 等这些功能。</p>
<p>PyCharm 教育版的功能虽然比专业版会少一些，但与社区版相比，更加支持学校的教学工作。</p>
<h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别:"></a>其他区别:</h3><p>PyCharm 的专业版是需要付费购买该软件的激活码才可以进行使用。</p>
<p>PyCharm 的社区版提供给开发者免费使用的。</p>
<p>PyCharm 的教育版只针对师生认证的用户才免费使用。</p>
<h3 id="适用人群不同"><a href="#适用人群不同" class="headerlink" title="适用人群不同"></a>适用人群不同</h3><p>PyCharm 的专业版是适用于一些公司进行专业互联网开发适用，这需要使用公司投入一定资金。</p>
<p>PyCharm 的社区版是提供给编程爱好者使用学术交流的，所以是免费提供的，其功能虽然不够全面，但能够满足日常开发需要。</p>
<p>PyCharm 的教育版则是以公益为目的免费提供给各大学校进行编程教学，发展编程教育事业。</p>
<p><strong>建议初学者选择社区版, 专业研究选择专业版.</strong></p>
<h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>先下载需要的 Python 版本(官网下载)</p>
<p><a href="https://www.python.org/">https://www.python.org/</a></p>
<p>Python安装教程:</p>
<p> <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624">https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624</a></p>
<p>下载 PyCharm(官网下载)</p>
<p><a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p>
<p><img src="https://download.yumie.xyz/img/2021090603102472.png"></p>
<p>左边是专业版, 右边是免费版(社区版)</p>
<h2 id="白嫖专业版-可选"><a href="#白嫖专业版-可选" class="headerlink" title="白嫖专业版(可选)"></a>白嫖专业版(可选)</h2><blockquote>
<p><strong>!!!社区版直接跳过这一步</strong></p>
</blockquote>
<p>如果是大学生, 可以在官网上认证, 免费试用一年, 但是时间太短, 我们采用一劳永逸的方法:</p>
<p>安装完专业版, 选择试用, 先随便新建一个项目进入主界面</p>
<p>找到 Settings/Preferences… -&gt; Plugins</p>
<p><img src="https://download.yumie.xyz/img/image-20220119175443234.png" alt="image-20220119175443234"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119175502592.png" alt="image-20220119175502592"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119175511722.png" alt="image-20220119175511722"></p>
<p>手动添加第三方插件仓库地址：<a href="https://plugins.zhile.io/">https://plugins.zhile.io</a></p>
<p>搜索：IDE Eval Reset 插件进行安装</p>
<p>安装成功之后, 首次运行</p>
<p><img src="https://download.yumie.xyz/img/image-20220119175722751.png" alt="image-20220119175722751"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119175754232.png" alt="image-20220119175754232"></p>
<p>勾选 Auto reset before per restart , 勾选之后点击 Reset</p>
<p>接着一路 yes/ok, 重启 PyCharm 过后就可以了</p>
<p>在每次 Pycharm 重启的时候都会自动续期</p>
<p>这样就可以拥有无限的试用时间, 相当于免费了</p>
<h2 id="初次打开-新建项目"><a href="#初次打开-新建项目" class="headerlink" title="初次打开, 新建项目"></a>初次打开, 新建项目</h2><p><img src="https://download.yumie.xyz/img/image-20220119175834654.png" alt="image-20220119175834654"></p>
<p>我们点击 New Project</p>
<p><img src="https://download.yumie.xyz/img/image-20220119175929740.png" alt="image-20220119175929740"></p>
<p>建议不要把代码放在 c 盘, 因为很多人找不到这个位置在哪, 那么放在其他磁盘中就能解决这个问题</p>
<p>其他的不用更改, 因为 PyCharm 会自动更改下面虚拟环境的路径</p>
<p><strong>为什么要用虚拟环境???</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在实际项目开发中，我们通常会根据自己的需求去下载各种相应的框架库，如 Scrapy、Beautiful Soup 等，但是可能每个项目使用的框架库并不一样，或使用框架的版本不一样，这样需要我们根据需求不断的更新或卸载相应的库。直接怼我们的 Python 环境操作会让我们的开发环境和项目造成很多不必要的麻烦，管理也相当混乱。</span><br></pre></td></tr></table></figure>

<p>点击 Create</p>
<p>那么现在项目就创建成功了，勾选 Show tips on startup，不用每次都打开欢迎界面，然后关闭即可。</p>
<p>到现在, 项目已经创建完毕了</p>
<h2 id="设置中文界面"><a href="#设置中文界面" class="headerlink" title="设置中文界面"></a>设置中文界面</h2><p>File &gt; Setting &gt; Plugins &gt; Marketplace</p>
<p>搜索 Chinese</p>
<p><img src="https://download.yumie.xyz/img/image-20220119180021047.png" alt="image-20220119180021047"></p>
<p>安装这个下载量最多的</p>
<p>完事后重启 PyCharm 就 ok 了</p>
<h2 id="下载插件-库速度太慢-换源"><a href="#下载插件-库速度太慢-换源" class="headerlink" title="下载插件/库速度太慢? 换源!"></a>下载插件/库速度太慢? 换源!</h2><p>打开 settings </p>
<p><img src="https://download.yumie.xyz/img/image-20220119180230546.png" alt="image-20220119180230546"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119180244617.png" alt="image-20220119180244617"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119180254596.png" alt="image-20220119180254596"></p>
<p><img src="https://download.yumie.xyz/img/image-20220119180302962.png" alt="image-20220119180302962"></p>
<p>输入清华源 <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 点击 ok</p>
<p>以后再在国内下载第三方库, 速度就会快很多了</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Python归并排序</title>
    <url>/20220120/Python%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>acwing习题</p>
<img src="https://download.yumie.xyz/img/image-20220120222139682.png" alt="image-20220120222139682" style="zoom:25%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120214537780.png" alt="image-20220120214537780"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = <span class="built_in">len</span>(array) // <span class="number">2</span></span><br><span class="line">    L = array[:mid]</span><br><span class="line">    R = array[mid:]</span><br><span class="line">    merge_sort(L)</span><br><span class="line">    merge_sort(R)</span><br><span class="line"> </span><br><span class="line">    i = j = k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(R):</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">            array[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[k] = R[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果左边/右边还有剩余的，则把剩余的添加到array中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L):</span><br><span class="line">        array[k] = L[i]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(R):</span><br><span class="line">        array[k] = R[j]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    list1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    merge_sort(list1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数的三次方根———二分法</title>
    <url>/20220120/Python%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9%E2%80%94%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>acwing习题</p>
<img src="https://download.yumie.xyz/img/image-20220120221937059.png" alt="image-20220120221937059" style="zoom:50%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120215123888.png" alt="image-20220120215123888"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsearch</span>(<span class="params">l, r</span>):</span></span><br><span class="line">    <span class="keyword">while</span> r - l &gt; <span class="number">1e-8</span>:</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mid ** <span class="number">3</span> &lt; n:</span><br><span class="line">            l = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">l = bsearch(-<span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(l))</span><br></pre></td></tr></table></figure>

<p>刚开始写的时候没有想到二分法。python的math库自带的pow算出来的不精确。</p>
<p>后来看了别人的题解才想到高中数学的一个求精确值的方法，就是不断循环比较。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Python版的闰年判断</title>
    <url>/20220120/Python%E7%89%88%E7%9A%84%E9%97%B0%E5%B9%B4%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>刷题记录</p>
<p><img src="https://download.yumie.xyz/img/image-20220120222441033.png" alt="image-20220120222441033"></p>
<span id="more"></span>

<p>闰年条件总是记不住？</p>
<p>Python内置库calendar帮你解决！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> calendar.isleap(x):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>再也不用担心忘记闰年的判断条件了</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue框架</title>
    <url>/20220120/Vue%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Vue框架的基础知识</p>
<img src="https://download.yumie.xyz/img/image-20220120222752944.png" alt="image-20220120222752944" style="zoom: 33%;" />

<span id="more"></span>

<h1 id="什么是vue？"><a href="#什么是vue？" class="headerlink" title="什么是vue？"></a><strong>什么是vue</strong>？</h1><p>是一套构建用户界面的<strong>渐进式</strong>（用到哪一块就用哪一块，不需要全部用上）前端框架，Vue 的核心库只关注视图层</p>
<p><img src="https://download.yumie.xyz/img/image-20220120165314243.png" alt="image-20220120165314243"></p>
<h1 id="对比其他框架-React"><a href="#对比其他框架-React" class="headerlink" title="对比其他框架-React"></a>对比其他框架-React</h1><p>React 和 Vue 有许多相似之处，它们都有使用 Virtual DOM；提供了响应式（Reactive）和组件化（Composable）的视图组件。将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。React 比 Vue 有更丰富的生态系统</p>
<p>都有支持native的方案，React的RN，vue的Wee下</p>
<p>都支持SSR服务端渲染</p>
<p>都支持props进行父子组件间的通信</p>
<p>性能方面：React 和 Vue 在大部分常见场景下都能提供近似的性能。通常 Vue 会有少量优势，因为 Vue 的 Virtual DOM 实现相对更为轻量一些。</p>
<p><strong>不同之处就是：</strong></p>
<ul>
<li>数据绑定方面，vue实现了数据的双向数据绑定，react数据流动是单向的</li>
<li>virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>
<li>state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理（如果要操作直接this.xxx）</li>
<li>组件写法不一样, React推荐的做法是 JSX , 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,js写在同一个文件</li>
</ul>
<h1 id="对比其他框架-angular"><a href="#对比其他框架-angular" class="headerlink" title="对比其他框架-angular"></a>对比其他框架-angular</h1><p>在性能方面，这两个框架都非常的快，我们也没有足够的实际应用数据来下一个结论。如果你一定想看些数据的话，你可以参考这个第三方跑分。单就这个跑分来看，Vue 似乎比 Angular 要更快一些。</p>
<p>在大小方面，最近的 Angular 版本中在使用了 AOT 和 tree-shaking 技术后使得最终的代码体积减小了许多。但即使如此，一个包含了 vuex + vue-router 的 Vue 项目 (30kb gzipped) 相比使用了这些优化的 Angular CLI 生成的默认项目尺寸 (~130kb) 还是要小的多。</p>
<p>灵活性：Vue 相比于 Angular 更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何组织你的应用代码。有人可能喜欢有严格的代码组织规范，但也有开发者喜欢更灵活自由的方式</p>
<h1 id="vue-js的核心特点—响应的数据绑定"><a href="#vue-js的核心特点—响应的数据绑定" class="headerlink" title="vue.js的核心特点—响应的数据绑定"></a><strong>vue.js的核心特点—响应的数据绑定</strong></h1><p>传统的js操作页面：在以前使用js操作页面的时候是这样的，需要操作某个html元素的数据，就的使用js代码获取元素然后在处理业务逻辑</p>
<p><img src="https://download.yumie.xyz/img/image-20220120165535317.png" alt="image-20220120165535317"></p>
<p>响应式数据绑定的方式操作页面，可以直接使用像下面代码那样的写法就可以将数据填充到页面中</p>
<p><img src="https://download.yumie.xyz/img/image-20220120165556815.png" alt="image-20220120165556815"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;app&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h1 id="vue-js的核心特点—可组合的视图组件"><a href="#vue-js的核心特点—可组合的视图组件" class="headerlink" title="vue.js的核心特点—可组合的视图组件"></a><strong>vue.js的核心特点—可组合的视图组件</strong></h1><p>一个页面映射为组件树。划分组件可维护、可重用、可测试，也就是一个页面由多个组件组合而成</p>
<p><img src="https://download.yumie.xyz/img/image-20220120165641632.png" alt="image-20220120165641632"></p>
<p>vue中实现组件引入示例</p>
<p>第一步：import导入需要引入的组件文件；</p>
<p>第二步：注册组件；</p>
<p>第三步：在需要引入组件的文件中加上组件标签（这个标签的标签名就是注册的组件名字，多个单词的和这里有xx-xx的形式）</p>
<p>需要注意的是：组件可以嵌套引入，也就是说组件可以引入其他组件</p>
<p>首先创建一个组件，用于被引入的组件，组件名字叫Hello.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Essential Links&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;hello&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>然后在需要引入的组件中，先使用import导入组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Hello from &#x27;./components/Hello&#x27;</span><br></pre></td></tr></table></figure>

<p>然后使用components注册这个组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要引入组件的文件中加上组件标签（这个标签的标签名就是注册的组件名字，多个单词的和这里有xx-xx的形式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hello&gt;&lt;/hello&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python的yield语句实现杨辉三角</title>
    <url>/20220120/%E5%88%A9%E7%94%A8Python%E7%9A%84yield%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>刷题记录</p>
<img src="https://download.yumie.xyz/img/image-20220120222649370.png" alt="image-20220120222649370" style="zoom: 50%;" />

<span id="more"></span>

<h1 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h1><p>yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后(下一行)开始。</p>
<p>Python 中的for A in B语法中的B是一个可迭代对象，而生成器(generator)是可以迭代的</p>
<p>迭代器与生成器的讲解：<a href="https://www.runoob.com/python3/python3-iterator-generator.html">Python3 迭代器与生成器 | 菜鸟教程 (runoob.com)</a></p>
<h1 id="为什么要有生成器"><a href="#为什么要有生成器" class="headerlink" title="为什么要有生成器?"></a>为什么要有生成器?</h1><p>列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。</p>
<p>如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p>
<p>简单一句话：我又想要得到庞大的数据，又想让它占用空间少，那就用生成器</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span>():</span></span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L.append(<span class="number">0</span>)</span><br><span class="line">        L = [L[i] + L[i - <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(L))]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> triangles():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="number">20</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h1><ul>
<li><p>L.append(0) 的作用是保证下一条语句的正确执行，这也是杨辉三角算法的其中一步</p>
</li>
<li><p>这里用a和len(a)来控制输出的长度，可以不用定义n = 0，简化了代码</p>
</li>
<li><p>列表推导式可以很简洁巧妙地实现杨辉三角的核心算法</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/20220121/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>介绍docker基本信息和一些基本操作</p>
<p><img src="https://download.yumie.xyz/img/image-20220121150920118.png" alt="image-20220121150920118"></p>
<span id="more"></span>

<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><h2 id="容器技术的起源"><a href="#容器技术的起源" class="headerlink" title="容器技术的起源"></a><strong>容器技术的起源</strong></h2><p>假设你们公司正在秘密研发下一个“今日头条”APP，我们姑且称为明日头条，程序员自己<strong>从头到尾搭建了一套环境</strong>开始写代码，写完代码后程序员要把代码交给测试同学测试，这时测试同学开始<strong>从头到尾搭建这套环境</strong>，测试过程中出现问题程序员也不用担心，大可以一脸无辜的撒娇，“明明在人家的环境上可以运行的”。</p>
<p>测试同学测完后终于可以上线了，这时运维同学又要重新<strong>从头到尾搭建这套环境</strong>，费了九牛二虎之力搭建好环境开始上线，糟糕，上线系统就崩溃了，这时心理素质好的程序员又可以施展演技了，“明明在人家的环境上可以运行的”。</p>
<p>从整个过程可以看到，不但我们重复搭建了三套环境还要迫使程序员转行演员浪费表演才华，典型的浪费时间和效率，聪明的程序员是永远不会满足现状的，因此又到了程序员改变世界的时候了，容器技术应运而生。</p>
<p>有的同学可能会说：“等等，先别改变世界，我们有虚拟机啊，VMware好用的飞起，先搭好一套虚拟机环境然后给测试和运维clone出来不就可以了吗？”</p>
<p>在没有容器技术之前，这确实是一个好办法，只不过这个办法还没有那么好。</p>
<p>先科普一下，现在云计算其底层的基石就是虚拟机技术，云计算厂商买回来一堆硬件搭建好数据中心后使用虚拟机技术就可以将硬件资源进行切分了，比如可以切分出100台虚拟机，这样就可以卖给很多用户了。</p>
<p>你可能会想这个办法为什么不好呢？</p>
<h2 id="容器技术-vs-虚拟机"><a href="#容器技术-vs-虚拟机" class="headerlink" title="容器技术 vs 虚拟机"></a><strong>容器技术 vs 虚拟机</strong></h2><p>我们知道和一个单纯的应用程序相比，<strong>操作系统是一个很重而且很笨的程序</strong>，简称笨重，有多笨重呢？</p>
<p>我们知道操作系统运行起来是需要占用很多资源的，大家对此肯定深有体会，刚装好的系统还什么都没有部署，单纯的操作系统其磁盘占用至少几十G起步，内存要几个G起步。</p>
<p>假设我有一台机器，16G内存，需要部署三个应用，那么使用虚拟机技术可以这样划分：</p>
<p><img src="https://download.yumie.xyz/img/image-20220121144125479.png" alt="image-20220121144125479"></p>
<p>在这台机器上开启三个虚拟机，每个虚拟机上部署一个应用，其中VM1占用2G内存，VM2占用1G内存，VM3占用了4G内存。</p>
<p>我们可以看到虚拟本身就占据了总共7G内存，因此<strong>我们没有办法划分出更过虚拟机从而部署更多的应用程序</strong>，可是我们部署的是应用程序，要用的也是应用程序而<strong>不是操作系统</strong>。</p>
<p>如果有一种技术可以让我们避免把内存浪费在“无用”的操作系统上岂不是太香？这是问题一，主要原因在于操作系统太重了。</p>
<p>还有另一个问题，那就是启动时间问题，我们知道操作系统重启是非常慢的，因为操作系统要从头到尾把该检测的都检测了该加载的都加载上，这个过程非常缓慢，动辄数分钟，因此操作系统还是太笨了。</p>
<p>那么有没有一种技术可以让我们获得虚拟机的好处又能克服这些缺点从而一举实现鱼和熊掌的兼得呢？</p>
<p>答案是肯定的，这就是容器技术。</p>
<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a><strong>什么是容器</strong></h2><p>容器一词的英文是container，其实container还有集装箱的意思，集装箱绝对是商业史上了不起的一项发明，大大降低了海洋贸易运输成本。让我们来看看集装箱的好处：</p>
<ul>
<li><p>集装箱之间相互隔离</p>
</li>
<li><p>长期反复使用</p>
</li>
<li><p>快速装载和卸载</p>
</li>
<li><p>规格标准，在港口和船上都可以摆放</p>
</li>
</ul>
<p>回到软件中的容器，其实容器和集装箱在概念上是很相似的。</p>
<p>现代软件开发的一大目的就是隔离，应用程序在运行时相互独立互不干扰，这种隔离实现起来是很不容易的，其中一种解决方案就是上面提到的虚拟机技术，通过将应用程序部署在不同的虚拟机中从而实现隔离。</p>
<img src="https://download.yumie.xyz/img/image-20220121144237539.png" alt="image-20220121144237539" style="zoom:50%;" />

<p>但是虚拟机技术有上述提到的各种缺点，那么容器技术又怎么样呢？</p>
<p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong>，这里的运行时环境指的是程序运行依赖的各种库以及配置。</p>
<img src="https://download.yumie.xyz/img/image-20220121144257263.png" alt="image-20220121144257263" style="zoom: 33%;" />

<p>从图中我们可以看到容器更加的<strong>轻量级且占用的资源更少</strong>，与操作系统动辄几G的内存占用相比，容器技术只需数M空间，因此我们可以在同样规格的硬件上<strong>大量部署容器</strong>，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为<strong>打包服务栈</strong>提供了一种更加高效的方式，So cool。</p>
<img src="https://download.yumie.xyz/img/image-20220121145229232.png" alt="image-20220121145229232" style="zoom:67%;" />

<p>那么我们该怎么使用容器呢？这就要讲到docker了。</p>
<p>注意，容器是一种通用技术，docker只是其中的一种实现。</p>
<h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a><strong>什么是docker</strong></h2><p>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p>
<p>因此我们可以看到docker可以屏蔽环境差异，也就是说，只要你的程序打包到了docker中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，<strong>不会再有“在我的环境上可以运行”</strong>，真正实现“build once, run everywhere”。</p>
<p>此外docker的另一个好处就是<strong>快速部署</strong>，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。</p>
<h2 id="如何使用docker"><a href="#如何使用docker" class="headerlink" title="如何使用docker"></a><strong>如何使用docker</strong></h2><p>docker中有这样几个概念：</p>
<ul>
<li>dockerfile</li>
<li>image</li>
<li>container</li>
</ul>
<p>实际上你可以简单的把image理解为可执行程序，container就是运行起来的进程。</p>
<p>那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是”编译器”。</p>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
<p>具体的使用方法就不再这里赘述了，大家可以参考docker的官方文档，那里有详细的讲解。</p>
<h2 id="docker是如何工作的"><a href="#docker是如何工作的" class="headerlink" title="docker是如何工作的"></a><strong>docker是如何工作的</strong></h2><p>实际上docker使用了常见的CS架构，也就是client-server模式，docker client负责处理用户输入的各种命令，比如docker build、docker run，真正工作的其实是server，也就是docker demon，值得注意的是，docker client和docker demon可以运行在同一台机器上。</p>
<p>接下来我们用几个命令来讲解一下docker的工作流程：</p>
<h3 id="1，docker-build"><a href="#1，docker-build" class="headerlink" title="1，docker build"></a><strong>1，docker build</strong></h3><p>当我们写完dockerfile交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据dockerfile创建出“可执行程序”image。</p>
<p><img src="https://download.yumie.xyz/img/image-20220121144442539.png" alt="image-20220121144442539"></p>
<h3 id="2，docker-run"><a href="#2，docker-run" class="headerlink" title="2，docker run"></a><strong>2，docker run</strong></h3><p>有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container。</p>
<p><img src="https://download.yumie.xyz/img/image-20220121144921294.png" alt="image-20220121144921294"></p>
<h3 id="3，docker-pull"><a href="#3，docker-pull" class="headerlink" title="3，docker pull"></a><strong>3，docker pull</strong></h3><p>其实docker build和docker run是两个最核心的命令，会用这两个命令基本上docker就可以用起来了，剩下的就是一些补充。</p>
<p>那么docker pull是什么意思呢？</p>
<p>我们之前说过，docker中image的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，那就是APP Store，即应用商店。与之类似，既然image也是一种“可执行程序”，那么有没有”Docker Image Store”呢？答案是肯定的，这就是Docker Hub，docker官方的“应用商店”，你可以在这里下载到别人编写好的image，这样你就不用自己编写dockerfile了。</p>
<p>docker registry 可以用来存放各种image，公共的可以供任何人下载image的仓库就是docker Hub。那么该怎么从Docker Hub中下载image呢，就是这里的docker pull命令了。</p>
<p>因此，这个命令的实现也很简单，那就是用户通过docker client发送命令，docker daemon接收到命令后向docker registry发送image下载请求，下载后存放在本地，这样我们就可以使用image了。</p>
<h1 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h1><h2 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h2><p>关闭容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>列出当前所有正在运行的container   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure>

<p>列出所有的container   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a  </span><br></pre></td></tr></table></figure>

<p>检索image   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search &lt;image_name&gt;</span><br></pre></td></tr></table></figure>

<p>下载image  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull &lt;image_name&gt; </span><br></pre></td></tr></table></figure>

<p>创建一个新的容器并运行一个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p>
</li>
<li><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p>
</li>
<li><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
</li>
<li><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p>
</li>
<li><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></p>
</li>
<li><p><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</p>
</li>
<li><p>**-m :**设置容器使用内存最大值；</p>
</li>
</ul>
<p>创建一个新的docker 名字为flask01**   <strong>做8090:81映射</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run -it -d --name flask01 -p 8090:81  flask</span><br></pre></td></tr></table></figure>

<p>433f54edf19e</p>
<p> sudo docker exec -it 433f54edf19e /bin/bash</p>
]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>win10/win11掉驱动问题</title>
    <url>/20220120/win10-win11%E6%8E%89%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%E2%80%9D/</url>
    <content><![CDATA[<p><img src="https://download.yumie.xyz/img/image-20220120215637286.png" alt="image-20220120215637286"></p>
<p>笔者在电脑新买回来的时候对网卡驱动不满意，于是自己从官网上下载了一个驱动程序装上。</p>
<p>刚开始用着没有任何问题，但是第二天早上到公司突然连不上网，一看设备管理器代码43</p>
<p>笔者就去查阅资料，发现是windows的驱动签名搞得鬼</p>
<span id="more"></span>

<blockquote>
<p>驱动签名指的是代码签名证书和软件签名证书的一种驱动程序，是一种包含数字签名的设备驱动程序。而数字签名是一种电子安全性标记，它可以指明软件的发行者，以及是否有人已更改驱动程序包的原始内容。如果驱动程序已由使用证书颁发机构验证其身份的发行者签名，则您可以确信驱动程序实际来自该发布者并且没有被更改。如果驱动程序没有签名，未由使用证书颁发机构验证其身份的发布者签名，或者自发行以来已进行了，那么客户端就无法正常使用了。</p>
<p>也就是说，如果没有驱动签名，那么根据管理员对计算机所进行的配置，Windows 可能忽略没有经过数字签名的设备驱动程序，并在它检测到没有数字签名的设备驱动程序时发出警告消息（默认行为），也可能会阻止您安装没有数字签名的设备驱动程序。不过因为这种驱动是针对整个数字证书的，所以任意的修改都会导致其无效，这样就避免了在驱动程序中添加恶意代码传播病毒等恶意程序的可能性。</p>
</blockquote>
<p>为了解除驱动签名，也是花了好久。</p>
<p>下面记录一下过程：</p>
<p>如何解除驱动签名：<a href="https://zhuanlan.zhihu.com/p/212078197">Win10家庭版找不到组策略gpedit.msc的解决方法 - 知乎 (zhihu.com)</a></p>
<p>网上搜到的教程都是win10的，但我的电脑是win11家庭版，不自带组策略，需要用命令行先开启组策略</p>
<p><a href="https://www.itechtics.com/enable-gpedit-msc-windows-11/">How To Enable Group Policy Editor (Gpedit.msc) In Windows 11 Home (itechtics.com)</a></p>
<p>最终完美解决</p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和(Python实现)</title>
    <url>/20220120/%E5%89%8D%E7%BC%80%E5%92%8C-Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>acwing练习题</p>
<img src="https://download.yumie.xyz/img/image-20220120221645268.png" alt="image-20220120221645268" style="zoom:50%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120221034615.png" alt="image-20220120221034615"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">prefix = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    prefix[i + <span class="number">1</span>] = prefix[i] + a[i]  <span class="comment"># 求前缀和</span></span><br><span class="line"><span class="comment"># print(prefix)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">print</span>(prefix[r] - prefix[l - <span class="number">1</span>])  <span class="comment"># 求部分和</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>最开始没把这道题放在眼里，也不知道要用前缀和算法去做。直接用切片索引出来，结果时间超限。</p>
<p>后来去网上查了资料才知道前缀和这种算法：</p>
<blockquote>
<p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。</p>
</blockquote>
<p>咱们的代码先初始化一个数组，然后遍历数组求前缀和，最后在索引，就可以很快地求出来其中一段的和</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用wordcloud库生成词云（Python）</title>
    <url>/20220120/%E5%88%A9%E7%94%A8wordcloud%E5%BA%93%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%EF%BC%88Python%EF%BC%89/</url>
    <content><![CDATA[<p>大二寒假，在公司闲暇时间完成了Python课程作业，记录一下:</p>
<p>题目：完成两个词云图</p>
<img src="https://download.yumie.xyz/img/image-20220120220330664.png" alt="image-20220120220330664" style="zoom:25%;" />

<span id="more"></span>

<p>（1）完成《中共中央关于党的百年奋斗重大成就和历史经验的决议》的词云，并解释词云体现的内涵意义。文本文档建文件“中共中央关于党的百年奋斗重大成就和历史经验的决议.txt”。决议总共七个部分，也可以只选择其中一部分或者几个部分形成新的.txt文件再做词云。（要求背景图片形状是一幅中国地图）。</p>
<p>（2）完成“郑州市第29场新冠肺炎疫情防控新闻发布会”的词云图，文本文件见“郑州市第29场新冠肺炎疫情防控新闻发布会.txt”。（要求背景图片形状是一幅穿防护服的白衣天使背景图像）。</p>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_wordcloud</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;中共中央关于党的百年奋斗重大成就和历史经验的决议.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        mask = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;image/china-map.png&quot;</span>))</span><br><span class="line">        text = f.read()</span><br><span class="line">        w = wordcloud.WordCloud(background_color=<span class="string">&quot;white&quot;</span>,</span><br><span class="line">                                font_path=<span class="string">&quot;C:/Windows/Fonts/simhei.ttf&quot;</span>,</span><br><span class="line">                                mask=mask)</span><br><span class="line">        w.generate(text)</span><br><span class="line">        w.to_file(<span class="string">&quot;output/中共中央关于党的百年奋斗重大成就和历史经验的决议.png&quot;</span>)</span><br><span class="line">        plt.imshow(w) </span><br><span class="line">        plt.show() </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second_wordcloud</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;郑州市第29场新冠肺炎疫情防控新闻发布会.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        mask = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;image/white-angel-withWhiteBackground-Highppi.png&quot;</span>))</span><br><span class="line">        text = f.read()</span><br><span class="line">        w = wordcloud.WordCloud(background_color=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">                                font_path=<span class="string">&quot;C:/Windows/Fonts/simhei.ttf&quot;</span>,</span><br><span class="line">                                mask=mask)</span><br><span class="line">        w.generate(text)</span><br><span class="line">        w.to_file(<span class="string">&quot;output/郑州市第29场新冠肺炎疫情防控新闻发布会.png&quot;</span>)</span><br><span class="line">        plt.imshow(w) </span><br><span class="line">        plt.show() </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    first_wordcloud()</span><br><span class="line">    second_wordcloud()</span><br></pre></td></tr></table></figure>

<p>因为之前做过词云，所以这次很快就做出来了，这是所呈现的效果（不要纠结为什么台湾没有画出来，这是因为那一块太小所以wordcloud没有填充进去）：</p>
<p><img src="https://download.yumie.xyz/img/image-20220120220449348.png" alt="image-20220120220449348"></p>
<p><img src="https://download.yumie.xyz/img/image-20220120220508499.png" alt="image-20220120220508499"></p>
<p>其中遇到的问题：</p>
<p>找mask图片是一个大问题。中国地图比较好找，我就在网上随便找了一个。但是发现生成的词云清晰度太低太低，连字都看不清。尝试改生成函数中的参数，发现不管用，因为用mask的情况下会强制以mask的分辨率作为最终生成图片的分辨率。</p>
<p><img src="https://download.yumie.xyz/img/image-20220120220541798.png" alt="image-20220120220541798"></p>
<p><img src="https://download.yumie.xyz/img/image-20220120220605840.png" alt="image-20220120220605840"></p>
<p>生成出来的图片很大很大：</p>
<p><img src="https://download.yumie.xyz/img/image-20220120220633780.png" alt="image-20220120220633780"></p>
<p>当然图片分辨率也不能提升太多，不然会报错：</p>
<p><img src="https://download.yumie.xyz/img/image-20220120220721088.png" alt="image-20220120220721088"></p>
<p> matplotlib库可以展示图片 </p>
<img src="https://download.yumie.xyz/img/image-20220120220737010.png" alt="image-20220120220737010" style="zoom:50%;" />

<p>在做第二张词云图的时候，遇到了一个棘手的问题。因为我找的医生图片背景是transparent的，在生成词云的时候效果很差。在网上找了很久，最终在Stack Overflow上找到解决方案：</p>
<p><a href="https://stackoverflow.com/questions/50435433/wordcloud-words-not-fitting-to-mask">python - wordcloud words not fitting to mask - Stack Overflow</a></p>
<p><img src="https://download.yumie.xyz/img/image-20220120220823537.png" alt="image-20220120220823537"></p>
<p>于是在网站上用工具把图片的transparent背景改成纯白RGB 255,255,255，就可以正常生成了</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯：01字串 Python实现</title>
    <url>/20220120/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A01%E5%AD%97%E4%B8%B2-Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>刷题记录</p>
<p><img src="https://download.yumie.xyz/img/image-20220120222558857.png" alt="image-20220120222558857"></p>
<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120212402565.png" alt="image-20220120212402565"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:05b&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure>

<p>本来我是想用bin() int(a,2)等方法来实现二进制的加法，但过于复杂。</p>
<p>这道题也可以用五重循环实现，但是很不优雅</p>
<p>最后参照了csdn上的一个代码，学习一下：</p>
<p>format语法教程：<a href="https://www.runoob.com/python/att-string-format.html">Python format 格式化函数 | 菜鸟教程 (runoob.com)</a></p>
<hr>
<p>0:05 中 第一个0是位置参数，代表后面的i ，其实也可以省略，达到同样的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:05b&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>: (冒)号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
</blockquote>
<p>而在本题中我们不足5位的数需要用“0”来填充</p>
<p>5前面其实省略了一个符号“&gt;” </p>
<blockquote>
<p>^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度</p>
</blockquote>
<p>5代表不足5位时用指定符号填充5位</p>
<p>完整代码应该是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:0&gt;5b&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>子矩阵的和(Python实现)</title>
    <url>/20220120/%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C-Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>acwing练习题</p>
<img src="https://download.yumie.xyz/img/image-20220120221524191.png" alt="image-20220120221524191" style="zoom:25%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120221317903.png" alt="image-20220120221317903"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入数据</span></span><br><span class="line">n, m, q = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">matrix = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    matrix.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">query = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">    query.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"> </span><br><span class="line">ls = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]  <span class="comment"># 初始化一个二维数组</span></span><br><span class="line"><span class="comment"># 这里尽量避免用两个列表来完成，因为这样会涉及到Python的深拷贝浅拷贝知识，初学者容易晕</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算前缀和</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        ls[i][j] = ls[i - <span class="number">1</span>][j] + ls[i][j - <span class="number">1</span>] - ls[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后的计算</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">    x1, y1, x2, y2 = query[i][<span class="number">0</span>], query[i][<span class="number">1</span>], query[i][<span class="number">2</span>], query[i][<span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(ls[x2][y2] - ls[x1 - <span class="number">1</span>][y2] - ls[x2][y1 - <span class="number">1</span>] + ls[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p> 这道题同样是使用前缀和的思想，再利用一些数学知识巧妙地通过求出的前缀和计算出子矩阵之和。跟之前发的一篇文章是差不多的，有兴趣的可以点开我的主页看上一篇文章。</p>
<p>从网上找到的算法分析：</p>
<p><img src="https://download.yumie.xyz/img/image-20220120221351501.png" alt="image-20220120221351501"></p>
<p><img src="https://download.yumie.xyz/img/image-20220120221400656.png" alt="image-20220120221400656"></p>
<img src="https://download.yumie.xyz/img/image-20220120221420586.png" alt="image-20220120221420586" style="zoom: 25%;" />

<p><img src="https://download.yumie.xyz/img/image-20220120221444427.png" alt="image-20220120221444427"></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记</title>
    <url>/20220126/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>acwing上学习算法基础课的笔记</p>
<img src="https://download.yumie.xyz/img/favicon.ico"  />

<span id="more"></span>

<h1 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原数组：a1 a2 a3 … ai</p>
<p>前缀和：Si = a1 + a2 + … +ai    S0 = 0</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>快速求出原数组中某一段的和</p>
<p>S[l, r] =<img src="https://download.yumie.xyz/img/image-20220126094636228.png" alt="image-20220126094636228" style="zoom:15%;" /></p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><img src="https://download.yumie.xyz/img/image-20220126094845832.png" alt="image-20220126094845832" style="zoom:50%;" />

<p>构造差分数组</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><img src="https://download.yumie.xyz/img/image-20220126094907156.png" alt="image-20220126094907156" style="zoom: 33%;" />

<p>让l到r这个范围中的每个数都+c（执行同样的操作）</p>
<img src="https://download.yumie.xyz/img/image-20220126094923922.png" alt="image-20220126094923922" style="zoom:67%;" />

<p>用O(1)的时间来给原数组中的某一区间的每个值，都加上一个值</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在搜题解的时候看到一句话说的很有道理：</p>
<blockquote>
<p>差分实质上就是前缀和的逆运算，主要解决连续多次在部分区间增加某个值 c 之后，求更新之后的数组</p>
</blockquote>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol start="797">
<li>差分</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。</span><br><span class="line"></span><br><span class="line">接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]之间的每个数加上 c。</span><br><span class="line"></span><br><span class="line">请你输出进行完所有操作后的序列。</span><br></pre></td></tr></table></figure>



<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line"></span><br><span class="line">第二行包含 n 个整数，表示整数序列。</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行包含三个整数 l，r，c表示一个操作。</span><br></pre></td></tr></table></figure>



<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共一行，包含 n 个整数，表示最终序列。</span><br></pre></td></tr></table></figure>



<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ≤ n, m ≤ 100000</span><br><span class="line">1 ≤ l ≤ r ≤ n</span><br><span class="line">−1000 ≤ c ≤ 1000</span><br><span class="line">−1000 ≤ 整数序列中元素的值 ≤ 1000</span><br></pre></td></tr></table></figure>



<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure>

<h4 id="问题求解："><a href="#问题求解：" class="headerlink" title="问题求解："></a>问题求解：</h4><p>类似于数学中的求导和积分，<strong>差分可以看成前缀和的逆运算</strong></p>
<p><strong>差分数组</strong>：</p>
<p>首先给定一个原数组<code>a</code>：<code>a[1], a[2], a[3],,,,,, a[n]</code>;</p>
<p>然后我们构造一个数组<code>b</code> ： <code>b[1] ,b[2] , b[3],,,,,, b[i]</code>;</p>
<p>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</code></p>
<p>也就是说，<code>a</code>数组是b数组的前缀和数组，反过来我们把<code>b</code>数组叫做<code>a</code>数组的差分数组。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。</p>
<p>考虑如何构造差分<code>b</code>数组？</p>
<p><strong>最为直接的方法如下：</strong></p>
<p><code>a[0]= 0</code></p>
<p><code>b[1] = a[1] - a[0]</code></p>
<p><code>b[2] = a[2] - a[1]</code></p>
<p><code>b[3] = a[3] - a[2]</code></p>
<p>…</p>
<p><code>b[n] = a[n] - a[n-1]</code></p>
<p>我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到a数组</p>
<p><strong>知道了差分数组有什么用呢？</strong> 别着急，慢慢往下看。</p>
<p><strong>这道题第一次遇到正常人的思路是</strong>：</p>
<p>给定区间<code>[l ,r]</code>，让我们把a数组中的<code>[l, r]</code>区间中的每一个数都加上<code>c</code>,</p>
<p>即 <code>a[l] + c , a[l+1] + c , a[l+2] + c , ... ,  a[r] + c</code></p>
<p>暴力做法是for循环<code>l</code>到<code>r</code>区间，时间复杂度<code>O(n)</code>，如果我们需要对原数组执行<code>m</code>次这样的操作，时间复杂度就会变成<code>O(n*m)</code>。有没有更高效的做法吗? 考虑差分做法。</p>
<p><strong>始终要记得，a数组是b数组的前缀和数组</strong>，比如对<code>b</code>数组的<code>b[i]</code>的修改，会影响到<code>a</code>数组中从<code>a[i]</code>及往后的每一个数。</p>
<p>首先让差分<code>b</code>数组中的 <code>b[l] + c</code> ,<code>a</code>数组变成 <code>a[l] + c ,a[l+1] + c, ... , a[n] + c</code></p>
<p>然后我们打个补丁，<code>b[r+1] - c</code>, <code>a</code>数组变成 <code>a[r+1] - c,a[r+2] - c, ... ,a[n] - c</code></p>
<p><strong>为啥还要打个补丁？</strong></p>
<p><strong>我们画个图理解一下这个公式的由来:</strong></p>
<p><img src="https://download.yumie.xyz/img/image-20220126143744018.png" alt="image-20220126143744018"></p>
<p><code>b[l] + c</code>，效果使得<code>a</code>数组中 <code>a[l]</code>及以后的数都加上了<code>c</code>(红色部分)，但我们只要求<code>l</code>到<code>r</code>区间加上<code>c</code>, 因此还需要执行 <code>b[r+1] - c</code>,让<code>a</code>数组中<code>a[r+1]</code>及往后的区间再减去<code>c</code>(绿色部分)，这样对于<code>a[r]</code> 以后区间的数相当于没有发生改变。</p>
<p>因此我们得出一维差分结论：给<code>a</code>数组中的<code>[l, r]</code>区间中的每一个数都加上<code>c</code>,只需对差分数组<code>b</code>做 <code>b[l] + = c</code>, <code>b[r+1] - = c</code>。时间复杂度为<code>O(1)</code>, 大大提高了效率。</p>
<p><strong>总结</strong>：</p>
<img src="https://download.yumie.xyz/img/image-20220126145236034.png" alt="image-20220126145236034" style="zoom: 67%;" />

<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 初始化数组</span></span><br><span class="line">a = [<span class="number">0</span>] * (n + <span class="number">10</span>)</span><br><span class="line">b = [<span class="number">0</span>] * (n + <span class="number">10</span>)</span><br><span class="line">a[<span class="number">1</span>:] = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]  <span class="comment"># 使a[0] = 0</span></span><br><span class="line"><span class="comment"># 构建差分数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    b[i] = a[i] - a[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    l, r, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    b[l] += c  <span class="comment"># 表示将序列中[l, r]之间的每个数加上c</span></span><br><span class="line">    b[r + <span class="number">1</span>] -= c  <span class="comment"># 除去多余部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    b[i] += b[i - <span class="number">1</span>]  <span class="comment"># 求前缀和运算</span></span><br><span class="line">    <span class="built_in">print</span>(b[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成功AC</p>
<img src="https://download.yumie.xyz/img/image-20220126161437967.png" alt="image-20220126161437967" style="zoom:50%;" />

<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>用的非常多的一种算法</p>
<p>很多时候意识不到</p>
<p>归并排序、快速排序 其实就用到了双指针算法</p>
<p>有两类：</p>
<ul>
<li>两个指针指向两个序列</li>
<li>两个指针指向一个序列（比较多）</li>
</ul>
<img src="https://download.yumie.xyz/img/image-20220126163551156.png" alt="image-20220126163551156" style="zoom: 50%;" />

<p><strong>最核心用途：</strong></p>
<p>​    <img src="https://download.yumie.xyz/img/image-20220126163717730.png" alt="image-20220126163717730" style="zoom: 50%;" /></p>
<p>把这样的暴力算法 优化到 <code>O(n)</code></p>
<p><strong>典型例子</strong>：</p>
<p>将very like python这种字符串中的单词逐个输出，其中空格数量均为1</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1):</span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(str1) <span class="keyword">and</span> str1[j] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(str1[i:j])</span><br><span class="line">    i = j + <span class="number">1</span>  <span class="comment"># 这里不要忘了加1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<img src="https://download.yumie.xyz/img/image-20220126175452185.png" alt="image-20220126175452185" style="zoom:50%;" />

<p><strong>例题：</strong></p>
<ol start="799">
<li>最长连续不重复子序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</span><br></pre></td></tr></table></figure>

<p><strong>输入格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行包含整数 n。</span><br><span class="line"></span><br><span class="line">第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。</span><br></pre></td></tr></table></figure>

<p><strong>输出格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</span><br></pre></td></tr></table></figure>

<p><strong>数据范围</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ≤ n ≤ 105</span><br></pre></td></tr></table></figure>

<p><strong>输入样例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

















































<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2>]]></content>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Win11 右键菜单和资源管理器卡顿</title>
    <url>/20220120/%E8%A7%A3%E5%86%B3-Win11-%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E5%8D%A1%E9%A1%BF/</url>
    <content><![CDATA[<p>这个问题是win11新功能优化问题</p>
<p>我们可以通过改回原来的右键菜单和资源管理器来解决</p>
<img src="https://download.yumie.xyz/img/image-20220120221734565.png" alt="image-20220120221734565" style="zoom:50%;" />

<span id="more"></span>

<p><a href="https://download.yumie.xyz/img/win11%E6%94%B9%E5%8F%B3%E9%94%AE%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8.bat">https://download.yumie.xyz/img/win11改右键和资源管理器.bat</a></p>
<p><img src="https://download.yumie.xyz/img/image-20220120215932065.png" alt="image-20220120215932065"></p>
]]></content>
      <tags>
        <tag>Winodws</tag>
      </tags>
  </entry>
  <entry>
    <title>试题 基础练习 Fibonacci数列 Python实现</title>
    <url>/20220120/%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-Fibonacci%E6%95%B0%E5%88%97-Python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>刷题记录</p>
<img src="https://download.yumie.xyz/img/image-20220120222333742.png" alt="image-20220120222333742" style="zoom: 50%;" />

<span id="more"></span>

<p><img src="https://download.yumie.xyz/img/image-20220120213914273.png" alt="image-20220120213914273"></p>
<p>废话不多说，先上满分代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">F = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    F[i % <span class="number">3</span>] = (F[(i - <span class="number">1</span>) % <span class="number">3</span>] + F[(i - <span class="number">2</span>) % <span class="number">3</span>]) % <span class="number">10007</span></span><br><span class="line"><span class="built_in">print</span>(F[(n - <span class="number">1</span>) % <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>本题对时间和空间要求非常严格，尤其是最后两个测试</p>
<p><img src="https://download.yumie.xyz/img/image-20220120213957489.png" alt="image-20220120213957489"></p>
<p>在室友的帮助下完美AC</p>
<p>原理类似循环链表，通过巧妙地取余，实现在只有三个元素的列表内循环覆盖，最后再通过取余算出列表中的最新值</p>
<p>通过循环覆盖方式解决了内存超限的问题</p>
<p><img src="https://download.yumie.xyz/img/image-20220120214017840.png" alt="image-20220120214017840"></p>
<p>在循环过程中就对10007取余，解决了超时问题</p>
<p>室友提供的思路太强了！</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python列表的注意事项</title>
    <url>/20220126/python%E5%88%97%E8%A1%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>Python刷题时遇到的坑</p>
<p><img src="https://download.yumie.xyz/img/image-20220126160436773.png" alt="image-20220126160436773"></p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new = old[:]</span><br></pre></td></tr></table></figure>

<p>Python高手都知道这行代码是什么意思。它复制列表old到new。</p>
<p>但它对于新手来说会很困惑，所以我们应该避免使用这种方法。</p>
<p>可惜的是[:]这种方法经常被使用，可能是大家不知道更好、更优雅的列表复制法吧。</p>
<p>首先我们需要了解Python是如何管理对象和变量。</p>
<p><strong>Python没有C语言中的变量。在C语言中，变量不止是个名字，它是字节集合并真实存在于内存某个位置上。</strong></p>
<p><strong>而在Python中，变量仅仅是指向对象的标签。</strong></p>
<p>看看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>它表示我们创建了一个指引指向列表[1, 2, 3]，但是a其实不是列表。如果这时使</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p>我们此时并没有复制a所指引的列表。我们只是创建了一个新的标签b，然后将其指向a所指向的列表。</p>
<img src="https://download.yumie.xyz/img/image-20220126155228414.png" alt="image-20220126155228414" style="zoom:50%;" />

<p>如果你修改a，那你就同时修改了b，因为它们指向同一个列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>内建函数id()可以返回对象的唯一id。该id是对象的内存地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3086056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">3086056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [] <span class="comment"># Create a new list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">2946712</span></span><br></pre></td></tr></table></figure>

<p>可以看出a和b都指向同一个内存地址。c指向一个新建的空列表，因此指向了不同的地址。</p>
<p>现在我们要复制a指引的列表。我们必须创建新的列表，然后使用b指向它。</p>
<img src="https://download.yumie.xyz/img/image-20220126155358913.png" alt="image-20220126155358913" style="zoom:50%;" />

<p>这其实就是 new = old[:]</p>
<p>切片运算符[:]返回一个序列的切片</p>
<p><strong>切片过程是切下列表的一部分，创建新的列表，将切下的部分复制到新列表。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3086056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="number">3063400</span></span><br></pre></td></tr></table></figure>

<p>还有另一种列表复制方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">list</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3086056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">3086256</span></span><br></pre></td></tr></table></figure>

<p>Isn’t it better, less cryptic, and more pythonic?</p>
<p>a[:]看起来有点太像Perl。</p>
<p>不同于切片标记法，不了解Python的人也会明白b是一个列表。</p>
<p><strong>下次你看见[:]的时候试试使用list()替代，这样可以让你的代码更加可读。</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中for循环的坑</title>
    <url>/20220126/python%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>刷题时遇到一个坑，记录下来</p>
<span id="more"></span>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>今天在刷题时，用Python复现C++写的代码，发现结果怎么也不一样</p>
<p>调试了半天才发现一个严重问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    i = <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>这样的输出结果很明显 只可能是0 1 2 3 4   而不是3 3 3 3 3</p>
<p>因为<strong>python每次循环开始时都会对i重新赋值</strong>，所以在for循环中对i的修改不会影响到下次循环！</p>
<p><strong>这和C++中的for很不一样</strong></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>改写成while循环</p>
<p>但是请注意：<strong>while循环每次i并不会自动+1，要手动在while的最后写出来！！</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anki背GRE单词</title>
    <url>/20220208/Anki%E8%83%8CGRE%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>备考GRE的时候背单词记录分享</p>
<span id="more"></span>

<p>GRE要求词汇量大概为13000，而我现在的词汇量只有9000</p>
<p>5月28号考试，希望能一次过</p>
<p>使用词汇书：GRE镇考机经词7.0</p>
<p><img src="https://download.yumie.xyz/img/image-20220208154934387.png" alt="image-20220208154934387"></p>
<p>背单词流程：</p>
<p>① 先在 iPad 上把一页15个词编个号</p>
<img src="https://download.yumie.xyz/img/image-20220208155215149.png" alt="image-20220208155215149" style="zoom:50%;" />

<p>② 在 CCtalk 上看这15个词的讲解视频，并在 iPad 电子单词书上做笔记</p>
<img src="https://download.yumie.xyz/img/image-20220208155228393.png" alt="image-20220208155228393" style="zoom:50%;" />

<p>③ 对照着笔记，在 anki 中录入</p>
<img src="https://download.yumie.xyz/img/image-20220208155247210.png" alt="image-20220208155247210" style="zoom:33%;" />

<p>之后的复习安排就放心交给 anki 了，我所需要做的就是每天完成复习工作</p>
<p><img src="https://download.yumie.xyz/img/image-20220208155353071.png" alt="image-20220208155353071"></p>
<p><img src="https://download.yumie.xyz/img/image-20220208155421613.png" alt="image-20220208155421613"></p>
<p><img src="https://download.yumie.xyz/img/image-20220208155527254.png" alt="image-20220208155527254"></p>
<p><img src="https://download.yumie.xyz/img/image-20220208155546815.png" alt="image-20220208155546815"></p>
<p>给自己加油！争取一次过！</p>
]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>博客第一次维护</title>
    <url>/20220418/%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p>电脑重装系统了，需要重新配一下环境</p>
<span id="more"></span>


<h1 id="windows环境配置"><a href="#windows环境配置" class="headerlink" title="windows环境配置"></a>windows环境配置</h1><p>先装nodejs，里面包含npm</p>
<p>下载地址：<a href="https://nodejs.org/en/">Node.js</a></p>
<p>然后在git bash中输入：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>


<p>然后安装一些需要的库，解除报错</p>
<p>20220418碰到的问题是：推送搜索引擎插件没有装，报一堆错</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">npm install &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<p>安装需要的包就可以了</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
